<!DOCTYPE html>
<html>
<head>
    <title>Simple Shader Test</title>
    <style>
        body { margin: 0; background: black; overflow-x: hidden; }
        #container { position: fixed; width: 100vw; height: 100vh; }
        #info { position: absolute; top: 20px; left: 20px; color: white; z-index: 100; }
        #content { height: 300vh; }
        #debug { position: absolute; top: 100px; left: 20px; color: red; z-index: 100; font-size: 20px; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <h2>Simple Shader Test</h2>
        <p>Basic shoe with hover detection</p>
    </div>
    <div id="debug">Starting...</div>
    <div id="controls" style="position: absolute; top: 200px; left: 20px; color: white; z-index: 100; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px;">
        <h3>Edge Detection Settings</h3>
        <label>Base Threshold: <span id="baseValue">0.3</span></label><br>
        <input type="range" id="baseThreshold" min="0.01" max="1.0" step="0.01" value="0.3"><br><br>
        
        <label>Hover Threshold: <span id="hoverValue">0.15</span></label><br>
        <input type="range" id="hoverThreshold" min="0.01" max="1.0" step="0.01" value="0.15"><br><br>
        
        <label>Edge Intensity: <span id="intensityValue">1.0</span></label><br>
        <input type="range" id="edgeIntensity" min="0.1" max="2.0" step="0.1" value="1.0"><br><br>
        
        <button onclick="resetDefaults()">Reset Defaults</button>
    </div>
    <div id="content"></div>

    <script src="three.min.js"></script>
    <script src="GLTFLoader.js"></script>
    <script src="OrbitControls.js"></script>
    <script>
        var scene, camera, renderer, model, controls, scrollY = 0;
        var raycaster, mouse = new THREE.Vector2();
        var modelChildren = [];
        var hoveredMesh = null;
        var renderTargetA, renderTargetB, sobelMaterial;
        var meshUuidToName = {};
        var selectedMeshName = null;
        
        document.getElementById('debug').innerHTML = 'Setting up Three.js...';
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 10);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        
        var light = new THREE.AmbientLight(0xffffff, 1);
        scene.add(light);
        
        raycaster = new THREE.Raycaster();
        
        // Create render targets
        function createRenderTargets() {
            const rtParams = {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            };
            
            renderTargetA = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtParams);
            renderTargetB = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtParams);
        }
        
        // Create distance-based material for clean edge detection
        function createDistanceMaterial(color) {
            return new THREE.ShaderMaterial({
                uniforms: {
                    uColor: { value: color }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    void main() {
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vPosition;
                    uniform vec3 uColor;
                    
                    void main() {
                        float dist = distance(vPosition, cameraPosition);
                        float normalizedDist = clamp(dist / 20.0, 0.0, 1.0);
                        float lum = dot(uColor, vec3(0.299, 0.587, 0.114));
                        gl_FragColor = vec4(vec3(lum), normalizedDist);
                    }
                `
            });
        }
        
        // Create Sobel shader
        function createSobelMaterial() {
            return new THREE.ShaderMaterial({
                uniforms: {
                    tDiffuse1: { value: null },
                    tDiffuse2: { value: null },
                    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    baseThreshold: { value: 0.3 },
                    hoverThreshold: { value: 0.15 },
                    edgeIntensity: { value: 1.0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse1;
                    uniform sampler2D tDiffuse2;
                    uniform vec2 resolution;
                    uniform float baseThreshold;
                    uniform float hoverThreshold;
                    uniform float edgeIntensity;
                    varying vec2 vUv;
                    
                    float sobel(sampler2D tex, vec2 texel) {
                        vec2 offset[9];
                        offset[0] = vec2(-texel.x, -texel.y);
                        offset[1] = vec2(0.0, -texel.y);
                        offset[2] = vec2(texel.x, -texel.y);
                        offset[3] = vec2(-texel.x, 0.0);
                        offset[4] = vec2(0.0, 0.0);
                        offset[5] = vec2(texel.x, 0.0);
                        offset[6] = vec2(-texel.x, texel.y);
                        offset[7] = vec2(0.0, texel.y);
                        offset[8] = vec2(texel.x, texel.y);
                        
                        float kernel[9];
                        kernel[0] = -1.0; kernel[1] = -2.0; kernel[2] = -1.0;
                        kernel[3] = 0.0;  kernel[4] = 0.0;  kernel[5] = 0.0;
                        kernel[6] = 1.0;  kernel[7] = 2.0;  kernel[8] = 1.0;
                        
                        float sum = 0.0;
                        for(int i = 0; i < 9; i++) {
                            vec4 color = texture2D(tex, vUv + offset[i]);
                            sum += dot(color.rgb, vec3(0.299, 0.587, 0.114)) * kernel[i];
                        }
                        
                        return abs(sum);
                    }
                    
                    void main() {
                        vec2 texel = vec2(1.0 / resolution.x, 1.0 / resolution.y);
                        
                        vec4 t1 = texture2D(tDiffuse1, vUv);
                        vec4 t2 = texture2D(tDiffuse2, vUv);
                        
                        // Start with black background
                        vec3 finalColor = vec3(0.0);
                        
                        // Show clean edges of all meshes - adjustable threshold
                        float baseEdges = sobel(tDiffuse1, texel);
                        if(baseEdges > baseThreshold) {
                            finalColor = vec3(edgeIntensity); // Adjustable intensity
                        }
                        
                        // If hovering over a mesh part, show its edges more prominently
                        if(t2.r > 0.1) {
                            float hoveredEdges = sobel(tDiffuse2, texel);
                            if(hoveredEdges > hoverThreshold) {
                                finalColor = vec3(1.0); // Bright white for hovered edges
                            }
                        }
                        
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `
            });
        }
        
        createRenderTargets();
        sobelMaterial = createSobelMaterial();
        
        // Setup UI controls
        function setupControls() {
            const baseSlider = document.getElementById('baseThreshold');
            const hoverSlider = document.getElementById('hoverThreshold');
            const intensitySlider = document.getElementById('edgeIntensity');
            
            const baseValue = document.getElementById('baseValue');
            const hoverValue = document.getElementById('hoverValue');
            const intensityValue = document.getElementById('intensityValue');
            
            baseSlider.addEventListener('input', function() {
                const value = parseFloat(this.value);
                baseValue.textContent = value.toFixed(2);
                sobelMaterial.uniforms.baseThreshold.value = value;
            });
            
            hoverSlider.addEventListener('input', function() {
                const value = parseFloat(this.value);
                hoverValue.textContent = value.toFixed(2);
                sobelMaterial.uniforms.hoverThreshold.value = value;
            });
            
            intensitySlider.addEventListener('input', function() {
                const value = parseFloat(this.value);
                intensityValue.textContent = value.toFixed(1);
                sobelMaterial.uniforms.edgeIntensity.value = value;
            });
        }
        
        window.resetDefaults = function() {
            document.getElementById('baseThreshold').value = 0.3;
            document.getElementById('hoverThreshold').value = 0.15;
            document.getElementById('edgeIntensity').value = 1.0;
            document.getElementById('baseValue').textContent = '0.30';
            document.getElementById('hoverValue').textContent = '0.15';
            document.getElementById('intensityValue').textContent = '1.0';
            sobelMaterial.uniforms.baseThreshold.value = 0.3;
            sobelMaterial.uniforms.hoverThreshold.value = 0.15;
            sobelMaterial.uniforms.edgeIntensity.value = 1.0;
        };
        
        setupControls();
        
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(modelChildren);
            
            if (intersects.length > 0) {
                const targetMesh = intersects[0].object;
                selectedMeshName = meshUuidToName[targetMesh.uuid] || targetMesh.uuid;
                document.getElementById('debug').innerHTML = 'Hovering: ' + (targetMesh.name || 'mesh part');
            } else {
                selectedMeshName = null;
                document.getElementById('debug').innerHTML = 'Move mouse over shoe parts for clean edges';
            }
        }
        
        document.getElementById('debug').innerHTML = 'Loading shoe...';
        
        var loader = new THREE.GLTFLoader();
        loader.load('shoe-nodraco.glb', 
            function(gltf) {
                document.getElementById('debug').innerHTML = 'SHOE LOADED!';
                model = gltf.scene;
                
                model.traverse(function(child) {
                    if (child.isMesh) {
                        modelChildren.push(child);
                        meshUuidToName[child.uuid] = child.name || child.uuid;
                        
                        // Use distance-based material for clean edge detection
                        const originalColor = new THREE.Color(0x00ff00);
                        child.material = createDistanceMaterial(originalColor);
                    }
                });
                
                var box = new THREE.Box3().setFromObject(model);
                var size = box.getSize(new THREE.Vector3());
                var maxSize = Math.max(size.x, size.y, size.z);
                var scale = 50 / maxSize;
                model.position.set(0, 0, 0);
                model.scale.setScalar(scale);
                scene.add(model);
                
                window.addEventListener('mousemove', onMouseMove);
                document.getElementById('debug').innerHTML = 'Move mouse over shoe parts for edge detection';
            },
            function(progress) {
                console.log('Loading:', (progress.loaded/progress.total*100) + '%');
            },
            function(error) {
                document.getElementById('debug').innerHTML = 'FAILED: ' + error.message;
                console.error('Error:', error);
            }
        );
        
        window.addEventListener('scroll', function() { scrollY = window.pageYOffset; });
        
        function render() {
            if (!model) return;
            
            // Apply scroll rotation
            var rot = scrollY * 0.005;
            model.rotation.y = rot;
            model.rotation.x = rot * 0.3;
            
            // Always render ALL meshes for base view
            modelChildren.forEach(function(mesh) {
                mesh.visible = true;
            });
            
            renderer.setRenderTarget(renderTargetA);
            renderer.render(scene, camera);
            
            // Render only hovered mesh (if any)
            if (selectedMeshName) {
                modelChildren.forEach(function(mesh) {
                    if (meshUuidToName[mesh.uuid] === selectedMeshName) {
                        mesh.visible = true;
                    } else {
                        mesh.visible = false;
                    }
                });
                
                renderer.setRenderTarget(renderTargetB);
                renderer.render(scene, camera);
            } else {
                // If nothing hovered, render empty target
                renderer.setRenderTarget(renderTargetB);
                renderer.clear();
            }
            
            // Reset visibility
            modelChildren.forEach(function(mesh) {
                mesh.visible = true;
            });
            
            // Apply clean Sobel effect
            sobelMaterial.uniforms.tDiffuse1.value = renderTargetA.texture;
            sobelMaterial.uniforms.tDiffuse2.value = renderTargetB.texture;
            
            renderer.setRenderTarget(null);
            
            var quadGeometry = new THREE.PlaneGeometry(2, 2);
            var quad = new THREE.Mesh(quadGeometry, sobelMaterial);
            var quadScene = new THREE.Scene();
            quadScene.add(quad);
            var quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            
            renderer.render(quadScene, quadCamera);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            render();
        }
        animate();
    </script>
</body>
</html>