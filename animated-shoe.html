<!DOCTYPE html>
<html>
<head>
    <title>Animated Shoe</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        body { 
            margin: 0; 
            background: black; 
            overflow-x: hidden; 
            cursor: pointer; 
            font-family: 'Inter', sans-serif;
        }
        #container { position: fixed; width: 100vw; height: 100vh; }
        #info { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            color: white; 
            z-index: 100; 
            font-family: 'Inter', sans-serif;
            font-weight: 400;
        }
        #debug { 
            position: absolute; 
            top: 100px; 
            left: 20px; 
            color: red; 
            z-index: 100; 
            font-size: 20px; 
            font-family: 'Inter', sans-serif;
            font-weight: 500;
        }
        #logo { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000; }
        #clickInfo { 
            position: absolute; 
            bottom: 30px; 
            left: 50%; 
            transform: translateX(-50%); 
            color: white; 
            z-index: 100; 
            text-align: center; 
            font-family: 'Inter', sans-serif;
            font-weight: 400;
        }
        #partsList {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 200px;
            max-height: 80vh;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            z-index: 100;
            font-family: 'Inter', sans-serif;
        }
        #partsList h3 {
            color: white;
            margin: 0 0 10px 0;
            font-weight: 600;
            font-size: 16px;
        }
        .part-item {
            color: #ccc;
            padding: 8px 12px;
            margin: 2px 0;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 400;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }
        .part-item:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-color: #555;
        }
        .part-item.active {
            background: rgba(255, 0, 0, 0.2);
            color: #ff6666;
            border-color: #ff0000;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="logo">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 111.7 42.9" style="height: 80px;">
          <defs>
            <style>
              .st0 {
                fill: #fff;
              }
            </style>
          </defs>
          <g id="SOLK">
            <g id="s">
              <path class="st0" d="M7.9,23.2h2.4c.3,2.1,2.2,2.9,5.7,2.9s5-1.2,5-2.6-.8-1.9-5.7-2.1c-5.3-.2-7.1-1.1-7.1-3.6s2.2-4.3,7.4-4.3,7.3,1.4,7.5,4.1h-2.2c-.2-1.5-1.8-2.4-5.5-2.4s-4.8,1-4.8,2.5,1.1,1.9,5.9,2.1c5.5.2,6.9,1.1,6.9,3.6s-2.2,4.6-7.4,4.6-7.6-1.3-8-4.6"/>
            </g>
            <g id="o">
              <path class="st0" d="M33.6,20.6c0-4.5,3.3-7.2,9.1-7.2s9,2.7,9,7.2-3.3,7.2-9,7.2-9.1-2.7-9.1-7.2M49.3,20.6c0-3.6-2.6-5.4-6.6-5.4s-6.7,1.8-6.7,5.4,2.6,5.4,6.7,5.4,6.6-1.8,6.6-5.4"/>
            </g>
            <g id="l">
              <polygon class="st0" points="65.6 25.7 76.7 25.7 76.7 27.6 63.3 27.6 63.3 13.6 65.6 13.6 65.6 25.7"/>
            </g>
            <g id="k">
              <polygon class="st0" points="103.7 13.6 103.7 13.7 94.7 20.1 103.7 27.6 103.7 27.6 100.7 27.6 93.1 21.3 90.6 23.1 90.6 27.6 88.2 27.6 88.2 13.6 90.6 13.6 90.6 20.9 100.6 13.6 103.7 13.6"/>
            </g>
          </g>
        </svg>
    </div>
    <div id="info">
        <h2>The Fade 101</h2>
        <p>Explosion animation</p>
    </div>
    <div id="debug">Starting...</div>
    <div id="clickInfo">Click anywhere to explode/reassemble the shoe</div>
    <div id="partsList">
        <h3>Parts</h3>
        <div id="partsListContent">Loading...</div>
    </div>
    <div id="content" style="height: 300vh;"></div>

    <script src="three.min.js"></script>
    <script src="GLTFLoader.js"></script>
    <script src="OrbitControls.js"></script>
    <script>
        var scene, camera, renderer, model, controls, scrollY = 0;
        var renderTargetA, renderTargetB, testMaterial;
        var modelChildren = [];
        var raycaster, mouse = new THREE.Vector2();
        var selectedMeshName = null;
        var meshUuidToName = {};
        var mixer, animationAction;
        var isExploded = false;
        var isAnimating = false;
        var isDragging = false;
        var dragStartTime = 0;
        var dragThreshold = 5; // pixels
        var hoveredFromList = null;
        var highlightedEdges = null;
        
        document.getElementById('debug').innerHTML = 'Setting up Three.js...';
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 8);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableZoom = false;
        
        var light = new THREE.AmbientLight(0xffffff, 1);
        scene.add(light);
        
        raycaster = new THREE.Raycaster();
        
        // Create dual render targets
        renderTargetA = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
        renderTargetB = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
        
        // Dual render target edge detection shader
        testMaterial = new THREE.ShaderMaterial({
            uniforms: {
                tDiffuse1: { value: null }, // All parts
                tDiffuse2: { value: null }, // Hovered part only
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse1; // All parts with edge detection
                uniform sampler2D tDiffuse2; // Hovered part as full wireframe
                uniform vec2 resolution;
                varying vec2 vUv;
                
                float detectEdges(sampler2D tex, vec2 texel) {
                    float center = texture2D(tex, vUv).r;
                    float left = texture2D(tex, vUv - vec2(texel.x, 0.0)).r;
                    float right = texture2D(tex, vUv + vec2(texel.x, 0.0)).r;
                    float up = texture2D(tex, vUv - vec2(0.0, texel.y)).r;
                    float down = texture2D(tex, vUv + vec2(0.0, texel.y)).r;
                    
                    float edge = abs(center - left) + abs(center - right) + 
                                abs(center - up) + abs(center - down);
                    
                    return edge > 0.05 ? 1.0 : 0.0;
                }
                
                void main() {
                    vec2 texel = vec2(1.0 / resolution.x, 1.0 / resolution.y);
                    
                    // Detect edges from all parts (white)
                    float baseEdges = detectEdges(tDiffuse1, texel);
                    
                    // Check if hovered part has wireframe content
                    vec4 hoveredWireframe = texture2D(tDiffuse2, vUv);
                    
                    // Start with white base edges
                    vec3 finalColor = vec3(baseEdges);
                    
                    // If hovered part has wireframe content, show it in red
                    if (hoveredWireframe.r > 0.1) {
                        finalColor = vec3(1.0, 0.0, 0.0); // Red wireframe for hovered part
                    }
                    
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        });
        
        function createHighlightEdges(mesh) {
            // Remove any existing highlight
            removeHighlightEdges();
            
            if (!mesh || !mesh.geometry) return;
            
            // Simply make this mesh red wireframe, hide all others
            modelChildren.forEach(function(m) {
                if (m.uuid === mesh.uuid) {
                    // Show this mesh as red wireframe
                    m.visible = true;
                    m.material.wireframe = true;
                    m.material.color.setHex(0xff0000);
                    highlightedEdges = m; // Store reference for cleanup
                } else {
                    // Hide all other meshes
                    m.visible = false;
                }
            });
            
            console.log('Set mesh to red wireframe');
        }
        
        function removeHighlightEdges() {
            // Reset all meshes to original state
            modelChildren.forEach(function(m) {
                m.visible = true;
                m.material.wireframe = false;
                m.material.color.copy(m.userData.originalColor);
            });
            highlightedEdges = null;
            console.log('Reset all meshes to original state');
        }
        
        function updatePartsListHighlight() {
            // Update parts list highlighting
            var partItems = document.querySelectorAll('.part-item');
            partItems.forEach(function(item) {
                if (item.dataset.meshId === selectedMeshName) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }
        
        function onMouseMove(event) {
            // Don't update selection if hovering from list
            if (hoveredFromList) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(modelChildren);
            
            if (intersects.length > 0) {
                const targetMesh = intersects[0].object;
                selectedMeshName = targetMesh.uuid;
                var partName = meshUuidToName[targetMesh.uuid] || targetMesh.name || 'mesh part';
                
                createHighlightEdges(targetMesh);
                document.getElementById('debug').innerHTML = 'Hovering: ' + partName;
                updatePartsListHighlight();
            } else {
                selectedMeshName = null;
                removeHighlightEdges();
                document.getElementById('debug').innerHTML = isExploded ? 'Exploded - Click to reassemble' : 'Assembled - Click to explode';
                updatePartsListHighlight();
            }
        }
        
        function createPartsList() {
            var partsListContent = document.getElementById('partsListContent');
            partsListContent.innerHTML = '';
            
            modelChildren.forEach(function(mesh, index) {
                var partName = mesh.name || ('Part_' + index);
                var meshId = mesh.uuid; // Use UUID directly for more reliable identification
                
                // Store the mesh reference for easier lookup
                meshUuidToName[meshId] = partName;
                
                var partItem = document.createElement('div');
                partItem.className = 'part-item';
                partItem.textContent = partName;
                partItem.dataset.meshId = meshId;
                partItem.dataset.meshIndex = index;
                
                partItem.addEventListener('mouseenter', function() {
                    hoveredFromList = meshId;
                    selectedMeshName = meshId;
                    
                    // Find the mesh and create clean edges
                    var targetMesh = modelChildren.find(function(m) { return m.uuid === meshId; });
                    if (targetMesh) {
                        createHighlightEdges(targetMesh);
                    }
                    
                    document.getElementById('debug').innerHTML = 'Highlighting: ' + partName;
                    updatePartsListHighlight();
                });
                
                partItem.addEventListener('mouseleave', function() {
                    hoveredFromList = null;
                    selectedMeshName = null;
                    
                    removeHighlightEdges();
                    document.getElementById('debug').innerHTML = isExploded ? 'Exploded - Click to reassemble' : 'Assembled - Click to explode';
                    updatePartsListHighlight();
                });
                
                partsListContent.appendChild(partItem);
            });
            
            console.log('Parts list created with', modelChildren.length, 'items');
        }
        
        var mouseDownPos = { x: 0, y: 0 };
        
        function onMouseDown(event) {
            mouseDownPos.x = event.clientX;
            mouseDownPos.y = event.clientY;
            isDragging = false;
        }
        
        function onMouseUp(event) {
            var deltaX = Math.abs(event.clientX - mouseDownPos.x);
            var deltaY = Math.abs(event.clientY - mouseDownPos.y);
            var dragDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            // Only trigger animation if we didn't drag
            if (dragDistance < dragThreshold) {
                onClick(event);
            }
        }
        
        function onClick(event) {
            if (isAnimating || !mixer || !mixer.allActions) return;
            
            isAnimating = true;
            
            if (isExploded) {
                // Play reverse animation (reassemble) for all actions
                mixer.allActions.forEach(function(action) {
                    action.timeScale = -1;
                    action.paused = false;
                    action.play();
                });
                isExploded = false;
                document.getElementById('debug').innerHTML = 'Reassembling...';
            } else {
                // Play forward animation (explode) for all actions
                mixer.allActions.forEach(function(action) {
                    action.timeScale = 1;
                    action.paused = false;
                    action.play();
                });
                isExploded = true;
                document.getElementById('debug').innerHTML = 'Exploding...';
            }
        }
        
        var altPressed = false;
        
        window.addEventListener('keydown', function(e) {
            if (e.altKey) altPressed = true;
        });
        
        window.addEventListener('keyup', function(e) {
            if (!e.altKey) altPressed = false;
        });
        
        window.addEventListener('wheel', function(e) {
            if (altPressed) {
                // Allow zoom when alt is pressed
                controls.enableZoom = true;
            } else {
                // Disable zoom and handle scroll rotation
                controls.enableZoom = false;
                e.preventDefault();
                scrollY += e.deltaY * 0.5;
            }
        });
        
        window.addEventListener('scroll', function() { scrollY = window.pageYOffset; });
        
        document.getElementById('debug').innerHTML = 'Loading animated shoe...';
        
        var loader = new THREE.GLTFLoader();
        loader.load('shoe_anim.glb', 
            function(gltf) {
                document.getElementById('debug').innerHTML = 'ANIMATED SHOE LOADED!';
                model = gltf.scene;
                
                // Set up animation mixer
                mixer = new THREE.AnimationMixer(model);
                
                if (gltf.animations.length > 0) {
                    // Play all animations, not just the first one
                    var actions = [];
                    gltf.animations.forEach(function(clip, index) {
                        var action = mixer.clipAction(clip);
                        action.setLoop(THREE.LoopOnce);
                        action.clampWhenFinished = true;
                        
                        // Start at first frame
                        action.time = 0;
                        action.paused = true;
                        action.play();
                        
                        actions.push(action);
                        console.log('Set up animation:', clip.name || 'Animation_' + index);
                    });
                    
                    // Use the first action as main control, but sync all actions
                    animationAction = actions[0];
                    
                    // Store all actions for synchronized control
                    mixer.allActions = actions;
                    
                    // Listen for animation completion
                    mixer.addEventListener('finished', function() {
                        isAnimating = false;
                        document.getElementById('debug').innerHTML = isExploded ? 'Exploded - Click to reassemble' : 'Assembled - Click to explode';
                    });
                    
                    document.getElementById('debug').innerHTML = 'Animation ready (' + gltf.animations.length + ' clips) - Click to explode!';
                } else {
                    document.getElementById('debug').innerHTML = 'No animations found in model';
                }
                
                model.traverse(function(child) {
                    if (child.isMesh) {
                        modelChildren.push(child);
                        meshUuidToName[child.uuid] = child.name || child.uuid;
                        
                        // Give each mesh part a different gray value so edge detector sees boundaries
                        var meshIndex = modelChildren.length - 1;
                        var grayValue = 0.3 + (meshIndex * 0.1) % 0.7; // Different gray values
                        
                        child.material = new THREE.MeshBasicMaterial({
                            color: new THREE.Color(grayValue, grayValue, grayValue)
                        });
                        
                        // Store original material properties for reset
                        child.userData.originalColor = new THREE.Color(grayValue, grayValue, grayValue);
                        child.userData.originalWireframe = false;
                    }
                });
                
                // Create the parts list
                createPartsList();
                
                // Scale the model
                var box = new THREE.Box3().setFromObject(model);
                var center = box.getCenter(new THREE.Vector3());
                var size = box.getSize(new THREE.Vector3());
                var maxSize = Math.max(size.x, size.y, size.z);
                var scale = 8 / maxSize;
                
                model.position.copy(center).multiplyScalar(-scale);
                model.scale.setScalar(scale);
                scene.add(model);
                
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('mousedown', onMouseDown);
                window.addEventListener('mouseup', onMouseUp);
            },
            function(progress) {
                console.log('Loading:', (progress.loaded/progress.total*100) + '%');
            },
            function(error) {
                document.getElementById('debug').innerHTML = 'FAILED: ' + error.message;
                console.error('Error:', error);
            }
        );
        
        var clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            var delta = clock.getDelta();
            if (mixer) mixer.update(delta);
            
            if (model) {
                var rot = scrollY * 0.005;
                model.rotation.y = rot;
            }
            controls.update();
            
            if (model) {
                // If hovering from parts list, render directly without shader
                if (hoveredFromList) {
                    renderer.setRenderTarget(null);
                    renderer.render(scene, camera);
                    return; // Skip shader completely
                }
                
                // Normal shader-based rendering only when NOT hovering from list
                {
                    // Normal shader-based rendering
                    // Render renderTargetA (all parts)
                    modelChildren.forEach(function(mesh) {
                        mesh.visible = true;
                    });
                    
                    renderer.setRenderTarget(renderTargetA);
                    renderer.render(scene, camera);
                    
                    // Render renderTargetB (only hovered part as full wireframe)
                    if (selectedMeshName) {
                        modelChildren.forEach(function(mesh) {
                            if (mesh.uuid === selectedMeshName) {
                                mesh.visible = true;
                                // Change to wireframe mode for hovered part
                                mesh.material.wireframe = true;
                            } else {
                                mesh.visible = false;
                            }
                        });
                        
                        renderer.setRenderTarget(renderTargetB);
                        renderer.render(scene, camera);
                        
                        // Reset wireframe mode
                        modelChildren.forEach(function(mesh) {
                            if (mesh.uuid === selectedMeshName) {
                                mesh.material.wireframe = false;
                            }
                        });
                    } else {
                        // Clear renderTargetB if nothing is hovered
                        renderer.setRenderTarget(renderTargetB);
                        renderer.clear();
                    }
                    
                    // Reset visibility
                    modelChildren.forEach(function(mesh) {
                        mesh.visible = true;
                    });
                    
                    // Apply edge detection with both render targets
                    testMaterial.uniforms.tDiffuse1.value = renderTargetA.texture;
                    testMaterial.uniforms.tDiffuse2.value = renderTargetB.texture;
                    
                    renderer.setRenderTarget(null);
                    
                    // Create fullscreen quad for post-processing
                    var quadGeometry = new THREE.PlaneGeometry(2, 2);
                    var quad = new THREE.Mesh(quadGeometry, testMaterial);
                    var quadScene = new THREE.Scene();
                    quadScene.add(quad);
                    var quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                    
                    renderer.render(quadScene, quadCamera);
                }
            } else {
                // If no model yet, render normally
                renderer.render(scene, camera);
            }
        }
        animate();
    </script>
</body>
</html>