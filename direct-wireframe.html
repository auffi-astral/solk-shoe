<!DOCTYPE html>
<html>
<head>
    <title>Direct Wireframe</title>
    <style>
        body { margin: 0; background: black; overflow-x: hidden; }
        #container { position: fixed; width: 100vw; height: 100vh; }
        #info { position: absolute; top: 20px; left: 20px; color: white; z-index: 100; }
        #debug { position: absolute; top: 100px; left: 20px; color: red; z-index: 100; font-size: 20px; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <h2>Direct Wireframe</h2>
        <p>Simple wireframe without edge detection</p>
    </div>
    <div id="debug">Starting...</div>

    <script src="three.min.js"></script>
    <script src="GLTFLoader.js"></script>
    <script src="OrbitControls.js"></script>
    <script>
        var scene, camera, renderer, model, controls, scrollY = 0;
        var modelChildren = [];
        var raycaster, mouse = new THREE.Vector2();
        var selectedMeshName = null;
        var meshUuidToName = {};
        
        document.getElementById('debug').innerHTML = 'Setting up Three.js...';
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 8);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        
        var light = new THREE.AmbientLight(0xffffff, 1);
        scene.add(light);
        
        raycaster = new THREE.Raycaster();
        
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(modelChildren);
            
            // Reset all to white wireframe
            modelChildren.forEach(function(mesh) {
                mesh.material.color.setHex(0xffffff);
            });
            
            if (intersects.length > 0) {
                const targetMesh = intersects[0].object;
                selectedMeshName = meshUuidToName[targetMesh.uuid] || targetMesh.uuid;
                
                // Highlight hovered mesh in red
                targetMesh.material.color.setHex(0xff0000);
                
                document.getElementById('debug').innerHTML = 'Hovering: ' + (targetMesh.name || 'mesh part');
            } else {
                selectedMeshName = null;
                document.getElementById('debug').innerHTML = 'Direct wireframe - no edge detection needed';
            }
        }
        
        document.getElementById('debug').innerHTML = 'Loading shoe...';
        
        var loader = new THREE.GLTFLoader();
        loader.load('shoe-nodraco.glb', 
            function(gltf) {
                document.getElementById('debug').innerHTML = 'SHOE LOADED!';
                model = gltf.scene;
                
                model.traverse(function(child) {
                    if (child.isMesh) {
                        modelChildren.push(child);
                        meshUuidToName[child.uuid] = child.name || child.uuid;
                        
                        // Direct wireframe material - no edge detection needed
                        child.material = new THREE.MeshBasicMaterial({
                            color: 0xffffff,
                            wireframe: true,
                            transparent: false
                        });
                    }
                });
                
                // Scale the model
                var box = new THREE.Box3().setFromObject(model);
                var center = box.getCenter(new THREE.Vector3());
                var size = box.getSize(new THREE.Vector3());
                var maxSize = Math.max(size.x, size.y, size.z);
                var scale = 8 / maxSize;
                
                model.position.copy(center).multiplyScalar(-scale);
                model.scale.setScalar(scale);
                scene.add(model);
                
                window.addEventListener('mousemove', onMouseMove);
                document.getElementById('debug').innerHTML = 'Direct wireframe - clean and simple!';
            },
            function(progress) {
                console.log('Loading:', (progress.loaded/progress.total*100) + '%');
            },
            function(error) {
                document.getElementById('debug').innerHTML = 'FAILED: ' + error.message;
                console.error('Error:', error);
            }
        );
        
        window.addEventListener('scroll', function() { scrollY = window.pageYOffset; });
        
        function animate() {
            requestAnimationFrame(animate);
            if (model) {
                var rot = scrollY * 0.005;
                model.rotation.y = rot;
                model.rotation.x = rot * 0.3;
            }
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>