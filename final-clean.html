<!DOCTYPE html>
<html>
<head>
    <title>Clean Shoe Wireframe</title>
    <style>
        body { margin: 0; background: black; overflow-x: hidden; }
        #container { position: fixed; width: 100vw; height: 100vh; }
        #info { position: absolute; top: 20px; left: 20px; color: white; z-index: 100; }
        #content { height: 300vh; }
        #debug { position: absolute; top: 100px; left: 20px; color: red; z-index: 100; font-size: 20px; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <h2>Clean Shoe</h2>
        <p>Exactly like your reference</p>
    </div>
    <div id="debug">Starting...</div>
    <div id="content"></div>

    <script src="three.min.js"></script>
    <script src="GLTFLoader.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="EffectComposer.js"></script>
    <script src="RenderPass.js"></script>
    <script src="ShaderPass.js"></script>
    <script>
        var scene, camera, renderer, model, controls, scrollY = 0;
        var raycaster, mouse = new THREE.Vector2();
        var modelChildren = [];
        var hoveredMesh = null;
        var renderTargetA, renderTargetB, sobelMaterial;
        var selectedMeshName = null;
        var meshUuidToName = {};
        
        document.getElementById('debug').innerHTML = 'Setting up Three.js...';
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 8);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        
        var light = new THREE.AmbientLight(0xffffff, 1);
        scene.add(light);
        
        raycaster = new THREE.Raycaster();
        
        // Create render targets
        function createRenderTargets() {
            const sizes = {
                width: window.innerWidth * Math.ceil(Math.min(2, window.devicePixelRatio)),
                height: window.innerHeight * Math.ceil(Math.min(2, window.devicePixelRatio))
            };
            
            const rtParams = {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            };
            
            renderTargetA = new THREE.WebGLRenderTarget(sizes.width, sizes.height, rtParams);
            renderTargetB = new THREE.WebGLRenderTarget(sizes.width, sizes.height, rtParams);
        }
        
        createRenderTargets();
        
        // Create dual render target Sobel shader
        var sobelShader = {
            uniforms: {
                tDiffuse1: { value: null },
                tDiffuse2: { value: null },
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse1;
                uniform sampler2D tDiffuse2;
                uniform vec2 resolution;
                varying vec2 vUv;

                float sobel(sampler2D tDiffuse, vec2 texel) {
                    // kernel definition (in glsl matrices are filled in column-major order)
                    const mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 ); // x direction kernel
                    const mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 ); // y direction kernel

                    // fetch the 3x3 neighbourhood of a fragment
                    // first column
                    float tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;
                    float tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;
                    float tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;

                    // second column
                    float tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;
                    float tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;
                    float tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;

                    // third column
                    float tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;
                    float tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;
                    float tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;

                    // gradient value in x direction
                    float valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 +
                        Gx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 +
                        Gx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2;

                    // gradient value in y direction
                    float valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 +
                        Gy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 +
                        Gy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2;

                    // magnitude of the total gradient
                    float G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );
                    return G;
                }

                void main() {
                    vec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );
                    
                    vec4 t1 = texture2D(tDiffuse1, vUv);
                    vec4 t2 = texture2D(tDiffuse2, vUv);
                    
                    // Debug: show raw render targets first
                    // gl_FragColor = vec4(t1.rgb, 1.0); // Uncomment to see renderTargetA
                    // gl_FragColor = vec4(t2.rgb, 1.0); // Uncomment to see renderTargetB
                    
                    if(t1.a == 0.0) {
                        t1.a = 1.0;
                    }
                    if(t2.a == 0.0) {
                        t2.a = 1.0;
                    }
                    
                    // Always show edges from renderTargetA (all meshes)
                    float G = sobel(tDiffuse1, texel);
                    G = G > 0.01 ? 1.0 : 0.0; // Higher threshold for visibility
                    
                    // If there's a hovered mesh, show its edges instead
                    if(t2.r > 0.1) {
                        float Gs = sobel(tDiffuse2, texel);
                        Gs = Gs > 0.01 ? 1.0 : 0.0;
                        G = max(G, Gs); // Combine both edge sets
                    }
                    
                    gl_FragColor = vec4(vec3(G), 1.0);
                }
            `
        };
        
        // Create distance-based material
        function createDistanceMaterial(color) {
            return new THREE.ShaderMaterial({
                uniforms: {
                    uColor: { value: color }
                },
                vertexShader: `
                    #include <common>
                    varying vec3 vPosition;
                    void main() {
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    #include <common>
                    varying vec3 vPosition;
                    uniform vec3 uColor;
                    
                    float normalizeRange(float value, float oldMin, float oldMax, float newMin, float newMax) {
                        float normalized = (value - oldMin) / (oldMax - oldMin);
                        return newMin + (newMax - newMin) * normalized;
                    }
                    
                    void main() {
                        float dist = distance(vPosition, cameraPosition);
                        float l = luminance(uColor);
                        gl_FragColor = vec4(vec3(l), normalizeRange(dist, 0.0, 20.0, 0.0, 1.0));
                        #include <colorspace_fragment>
                    }
                `
            });
        }
        
        sobelMaterial = new THREE.ShaderMaterial(sobelShader);
        
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(modelChildren);
            
            if (intersects.length > 0) {
                const targetMesh = intersects[0].object;
                selectedMeshName = meshUuidToName[targetMesh.uuid] || targetMesh.uuid;
                document.getElementById('debug').innerHTML = 'Hovering: ' + (targetMesh.name || 'mesh part');
            } else {
                selectedMeshName = null;
                document.getElementById('debug').innerHTML = 'Clean edge detection with dual render targets';
            }
        }
        
        document.getElementById('debug').innerHTML = 'Loading shoe...';
        
        var loader = new THREE.GLTFLoader();
        loader.load('shoe-nodraco.glb', 
            function(gltf) {
                document.getElementById('debug').innerHTML = 'SHOE LOADED!';
                model = gltf.scene;
                
                model.traverse(function(child) {
                    if (child.isMesh) {
                        modelChildren.push(child);
                        meshUuidToName[child.uuid] = child.name || child.uuid;
                        
                        // Use distance-based material for proper depth comparison
                        const originalColor = new THREE.Color(0xffffff);
                        child.material = createDistanceMaterial(originalColor);
                    }
                });
                
                // Scale to fill most of screen like your reference
                var box = new THREE.Box3().setFromObject(model);
                var center = box.getCenter(new THREE.Vector3());
                var size = box.getSize(new THREE.Vector3());
                var maxSize = Math.max(size.x, size.y, size.z);
                
                // Much bigger scale to match your reference
                var scale = 8 / maxSize;
                
                // Center the model
                model.position.copy(center).multiplyScalar(-scale);
                model.scale.setScalar(scale);
                scene.add(model);
                
                window.addEventListener('mousemove', onMouseMove);
                document.getElementById('debug').innerHTML = 'Large clean wireframe - just like your reference!';
            },
            function(progress) {
                console.log('Loading:', (progress.loaded/progress.total*100) + '%');
            },
            function(error) {
                document.getElementById('debug').innerHTML = 'FAILED: ' + error.message;
                console.error('Error:', error);
            }
        );
        
        window.addEventListener('scroll', function() { scrollY = window.pageYOffset; });
        
        function render() {
            if (!model) return;
            
            // Apply scroll rotation
            var rot = scrollY * 0.005;
            model.rotation.y = rot;
            model.rotation.x = rot * 0.3;
            
            // Render renderTargetA (ALL meshes visible)
            modelChildren.forEach(function(mesh) {
                mesh.visible = true;
            });
            
            renderer.setRenderTarget(renderTargetA);
            renderer.render(scene, camera);
            
            // Render renderTargetB (only hovered mesh, if any)
            if (selectedMeshName) {
                modelChildren.forEach(function(mesh) {
                    if (meshUuidToName[mesh.uuid] === selectedMeshName) {
                        mesh.visible = true;
                    } else {
                        mesh.visible = false;
                    }
                });
                
                renderer.setRenderTarget(renderTargetB);
                renderer.render(scene, camera);
            } else {
                // Clear renderTargetB if nothing is hovered
                renderer.setRenderTarget(renderTargetB);
                renderer.clear();
            }
            
            // Reset visibility
            modelChildren.forEach(function(mesh) {
                mesh.visible = true;
            });
            
            // Apply Sobel effect with dual render targets
            sobelMaterial.uniforms.tDiffuse1.value = renderTargetA.texture;
            sobelMaterial.uniforms.tDiffuse2.value = renderTargetB.texture;
            
            renderer.setRenderTarget(null);
            
            // Create fullscreen quad for post-processing
            var quadGeometry = new THREE.PlaneGeometry(2, 2);
            var quad = new THREE.Mesh(quadGeometry, sobelMaterial);
            var quadScene = new THREE.Scene();
            quadScene.add(quad);
            var quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            
            renderer.render(quadScene, quadCamera);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            render();
        }
        animate();
    </script>
</body>
</html>