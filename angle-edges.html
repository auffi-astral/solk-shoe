<!DOCTYPE html>
<html>
<head>
    <title>Angle-Based Edge Detection</title>
    <style>
        body { margin: 0; background: black; overflow-x: hidden; }
        #container { position: fixed; width: 100vw; height: 100vh; }
        #info { position: absolute; top: 20px; left: 20px; color: white; z-index: 100; }
        #debug { position: absolute; top: 100px; left: 20px; color: red; z-index: 100; font-size: 20px; }
        #controls { position: absolute; top: 150px; left: 20px; color: white; z-index: 100; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <h2>Angle-Based Edges</h2>
        <p>Geometric edge detection using polygon angles</p>
    </div>
    <div id="debug">Starting...</div>
    <div id="controls">
        <label>Edge Angle Threshold: <span id="angleValue">30</span>°</label><br>
        <input type="range" id="angleThreshold" min="5" max="90" step="5" value="30"><br><br>
        <button onclick="updateEdges()">Update Edges</button>
    </div>

    <script src="three.min.js"></script>
    <script src="GLTFLoader.js"></script>
    <script src="OrbitControls.js"></script>
    <script>
        var scene, camera, renderer, model, controls, scrollY = 0;
        var renderTargetA, renderTargetB, edgeMaterial;
        var modelChildren = [];
        var raycaster, mouse = new THREE.Vector2();
        var selectedMeshName = null;
        var meshUuidToName = {};
        var edgeLines = [];
        
        document.getElementById('debug').innerHTML = 'Setting up Three.js...';
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 8);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        
        var light = new THREE.AmbientLight(0xffffff, 1);
        scene.add(light);
        
        raycaster = new THREE.Raycaster();
        
        // Create render targets for hover effect
        renderTargetA = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
        renderTargetB = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
        
        // Edge detection shader that combines base edges + hover highlighting
        edgeMaterial = new THREE.ShaderMaterial({
            uniforms: {
                tDiffuse1: { value: null }, // All edges
                tDiffuse2: { value: null }, // Hovered edges only
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse1; // All edges
                uniform sampler2D tDiffuse2; // Hovered edges only
                uniform vec2 resolution;
                varying vec2 vUv;
                
                void main() {
                    vec4 baseEdges = texture2D(tDiffuse1, vUv);
                    vec4 hoveredEdges = texture2D(tDiffuse2, vUv);
                    
                    // White base edges
                    vec3 finalColor = baseEdges.rgb;
                    
                    // Red hovered edges override base
                    if (hoveredEdges.r > 0.1) {
                        finalColor = vec3(1.0, 0.0, 0.0); // Red for hovered parts
                    }
                    
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        });
        
        function createAngleBasedEdges(mesh, angleThreshold) {
            var geometry = mesh.geometry;
            var position = geometry.attributes.position;
            var vertices = [];
            var faces = [];
            
            // Extract vertices
            for (let i = 0; i < position.count; i++) {
                vertices.push(new THREE.Vector3(
                    position.getX(i),
                    position.getY(i), 
                    position.getZ(i)
                ));
            }
            
            // Extract faces (assuming triangles)
            for (let i = 0; i < position.count; i += 3) {
                faces.push({
                    a: i,
                    b: i + 1,
                    c: i + 2,
                    normal: null
                });
            }
            
            // Calculate face normals
            faces.forEach(function(face) {
                var va = vertices[face.a];
                var vb = vertices[face.b];
                var vc = vertices[face.c];
                
                var cb = new THREE.Vector3().subVectors(vc, vb);
                var ab = new THREE.Vector3().subVectors(va, vb);
                var normal = new THREE.Vector3().crossVectors(cb, ab).normalize();
                
                face.normal = normal;
            });
            
            // Find edges with angle > threshold
            var edgeVertices = [];
            var edgeMap = new Map();
            
            faces.forEach(function(face, faceIndex) {
                var edges = [
                    [face.a, face.b],
                    [face.b, face.c],
                    [face.c, face.a]
                ];
                
                edges.forEach(function(edge) {
                    var key = Math.min(edge[0], edge[1]) + '_' + Math.max(edge[0], edge[1]);
                    
                    if (edgeMap.has(key)) {
                        // This edge is shared - check angle between faces
                        var otherFace = edgeMap.get(key);
                        var angle = Math.acos(Math.max(-1, Math.min(1, 
                            face.normal.dot(otherFace.normal)
                        ))) * 180 / Math.PI;
                        
                        if (angle > angleThreshold) {
                            // Add edge line
                            edgeVertices.push(
                                vertices[edge[0]].x, vertices[edge[0]].y, vertices[edge[0]].z,
                                vertices[edge[1]].x, vertices[edge[1]].y, vertices[edge[1]].z
                            );
                        }
                    } else {
                        edgeMap.set(key, face);
                    }
                });
            });
            
            // Create edge geometry
            var edgeGeometry = new THREE.BufferGeometry();
            edgeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(edgeVertices, 3));
            
            return edgeGeometry;
        }
        
        function createEdgesForAllMeshes(angleThreshold) {
            // Clear existing edge lines
            edgeLines.forEach(function(line) {
                scene.remove(line);
            });
            edgeLines = [];
            
            modelChildren.forEach(function(mesh, index) {
                var edgeGeometry = createAngleBasedEdges(mesh, angleThreshold);
                
                var edgeMaterial = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    linewidth: 1
                });
                
                var edgeLine = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                
                // Apply same transform as original mesh
                edgeLine.position.copy(mesh.position);
                edgeLine.rotation.copy(mesh.rotation);
                edgeLine.scale.copy(mesh.scale);
                edgeLine.userData.meshIndex = index;
                edgeLine.userData.originalMesh = mesh;
                
                scene.add(edgeLine);
                edgeLines.push(edgeLine);
            });
            
            // Hide original meshes
            modelChildren.forEach(function(mesh) {
                mesh.visible = false;
            });
        }
        
        window.updateEdges = function() {
            var threshold = parseFloat(document.getElementById('angleThreshold').value);
            document.getElementById('angleValue').textContent = threshold;
            
            if (modelChildren.length > 0) {
                createEdgesForAllMeshes(threshold);
                document.getElementById('debug').innerHTML = 'Updated edges with ' + threshold + '° threshold';
            }
        };
        
        document.getElementById('angleThreshold').addEventListener('input', function() {
            document.getElementById('angleValue').textContent = this.value;
        });
        
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(edgeLines);
            
            // Reset all edge lines to white
            edgeLines.forEach(function(line) {
                line.material.color.setHex(0xffffff);
            });
            
            if (intersects.length > 0) {
                var hoveredLine = intersects[0].object;
                var originalMesh = hoveredLine.userData.originalMesh;
                selectedMeshName = meshUuidToName[originalMesh.uuid] || originalMesh.uuid;
                
                // Highlight hovered edge lines in red
                hoveredLine.material.color.setHex(0xff0000);
                
                document.getElementById('debug').innerHTML = 'Hovering: Part ' + hoveredLine.userData.meshIndex;
            } else {
                selectedMeshName = null;
                document.getElementById('debug').innerHTML = 'Angle-based edge detection (' + document.getElementById('angleValue').textContent + '°)';
            }
        }
        
        document.getElementById('debug').innerHTML = 'Loading shoe...';
        
        var loader = new THREE.GLTFLoader();
        loader.load('shoe-nodraco.glb', 
            function(gltf) {
                document.getElementById('debug').innerHTML = 'SHOE LOADED!';
                model = gltf.scene;
                
                model.traverse(function(child) {
                    if (child.isMesh) {
                        modelChildren.push(child);
                        meshUuidToName[child.uuid] = child.name || child.uuid;
                    }
                });
                
                // Scale the model
                var box = new THREE.Box3().setFromObject(model);
                var center = box.getCenter(new THREE.Vector3());
                var size = box.getSize(new THREE.Vector3());
                var maxSize = Math.max(size.x, size.y, size.z);
                var scale = 8 / maxSize;
                
                model.position.copy(center).multiplyScalar(-scale);
                model.scale.setScalar(scale);
                scene.add(model);
                
                // Create angle-based edges
                createEdgesForAllMeshes(30);
                
                window.addEventListener('mousemove', onMouseMove);
                document.getElementById('debug').innerHTML = 'Angle-based edges created! Adjust threshold as needed.';
            },
            function(progress) {
                console.log('Loading:', (progress.loaded/progress.total*100) + '%');
            },
            function(error) {
                document.getElementById('debug').innerHTML = 'FAILED: ' + error.message;
                console.error('Error:', error);
            }
        );
        
        window.addEventListener('scroll', function() { scrollY = window.pageYOffset; });
        
        function animate() {
            requestAnimationFrame(animate);
            if (model) {
                var rot = scrollY * 0.005;
                model.rotation.y = rot;
                model.rotation.x = rot * 0.3;
            }
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>