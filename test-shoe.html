<!DOCTYPE html>
<html>
<head>
    <title>Test New Shoe</title>
    <style>
        body { margin: 0; background: black; overflow-x: hidden; }
        #container { position: fixed; width: 100vw; height: 100vh; }
        #info { position: absolute; top: 20px; left: 20px; color: white; z-index: 100; }
        #content { height: 300vh; }
        #debug { position: absolute; top: 100px; left: 20px; color: red; z-index: 100; font-size: 20px; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <h2>New Shoe Test</h2>
        <p>Scroll to rotate â€¢ Drag to orbit</p>
    </div>
    <div id="debug">Starting...</div>
    <div id="content"></div>

    <script src="three.min.js"></script>
    <script src="GLTFLoader.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="EffectComposer.js"></script>
    <script src="RenderPass.js"></script>
    <script src="ShaderPass.js"></script>
    <script src="SobelOperatorShader.js"></script>
    <script>
        var scene, camera, renderer, model, controls, scrollY = 0;
        var renderTargetA, renderTargetB, effectSobel, composer;
        var raycaster, mouse = new THREE.Vector2();
        var modelChildren = [];
        var selectedMeshName = null;
        var meshUuidToName = {};
        
        document.getElementById('debug').innerHTML = 'Setting up Three.js...';
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 10);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        
        var light = new THREE.AmbientLight(0xffffff, 1);
        scene.add(light);
        
        raycaster = new THREE.Raycaster();
        
        createRenderTargets();
        setupPostProcessing();
        
        function createRenderTargets() {
            const sizes = {
                width: window.innerWidth * Math.ceil(Math.min(2, window.devicePixelRatio)),
                height: window.innerHeight * Math.ceil(Math.min(2, window.devicePixelRatio))
            };
            
            const rtParams = {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                type: THREE.FloatType
            };
            
            renderTargetA = new THREE.WebGLRenderTarget(sizes.width, sizes.height, rtParams);
            renderTargetB = new THREE.WebGLRenderTarget(sizes.width, sizes.height, rtParams);
        }
        
        function setupPostProcessing() {
            // Custom Sobel shader with dual render target support
            const sobelShader = {
                uniforms: {
                    tDiffuse1: { value: null },
                    tDiffuse2: { value: null },
                    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse1;
                    uniform sampler2D tDiffuse2;
                    uniform vec2 resolution;
                    varying vec2 vUv;
                    
                    float sobel(sampler2D tex, vec2 texel) {
                        vec2 offset[9];
                        offset[0] = vec2(-texel.x, -texel.y);
                        offset[1] = vec2(0.0, -texel.y);
                        offset[2] = vec2(texel.x, -texel.y);
                        offset[3] = vec2(-texel.x, 0.0);
                        offset[4] = vec2(0.0, 0.0);
                        offset[5] = vec2(texel.x, 0.0);
                        offset[6] = vec2(-texel.x, texel.y);
                        offset[7] = vec2(0.0, texel.y);
                        offset[8] = vec2(texel.x, texel.y);
                        
                        float kernel[9];
                        kernel[0] = -1.0; kernel[1] = -2.0; kernel[2] = -1.0;
                        kernel[3] = 0.0;  kernel[4] = 0.0;  kernel[5] = 0.0;
                        kernel[6] = 1.0;  kernel[7] = 2.0;  kernel[8] = 1.0;
                        
                        float sum = 0.0;
                        for(int i = 0; i < 9; i++) {
                            vec4 color = texture2D(tex, vUv + offset[i]);
                            sum += dot(color.rgb, vec3(0.299, 0.587, 0.114)) * kernel[i];
                        }
                        
                        return abs(sum);
                    }
                    
                    void main() {
                        vec2 texel = vec2(1.0 / resolution.x, 1.0 / resolution.y);
                        
                        vec4 t1 = texture2D(tDiffuse1, vUv);
                        vec4 t2 = texture2D(tDiffuse2, vUv);
                        
                        if(t1.a == 0.0) t1.a = 1.0;
                        if(t2.a == 0.0) t2.a = 1.0;
                        
                        float G = sobel(tDiffuse1, texel);
                        G = G > 0.001 ? 1.0 : 0.0;
                        float Gs = sobel(tDiffuse2, texel);
                        Gs = Gs > 0.001 ? 1.0 : 0.0;
                        
                        vec4 s1 = vec4(vec3(G), 1.0);
                        vec4 s2 = vec4(vec3(Gs), 1.0);
                        vec4 sobelTexture = vec4(vec3(0.0), 1.0);
                        
                        if(t1.a > t2.a) {
                            sobelTexture = s2;
                        } else {
                            sobelTexture = s1;
                        }
                        
                        gl_FragColor = sobelTexture;
                    }
                `
            };
            
            effectSobel = new THREE.ShaderMaterial(sobelShader);
        }
        
        function createDistanceMaterial(color) {
            return new THREE.ShaderMaterial({
                uniforms: {
                    uColor: { value: color }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    void main() {
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    #include <common>
                    varying vec3 vPosition;
                    uniform vec3 uColor;
                    
                    float normalizeRange(float value, float oldMin, float oldMax, float newMin, float newMax) {
                        float normalized = (value - oldMin) / (oldMax - oldMin);
                        return newMin + (newMax - newMin) * normalized;
                    }
                    
                    void main() {
                        float dist = distance(vPosition, cameraPosition);
                        float l = luminance(uColor);
                        gl_FragColor = vec4(vec3(l), normalizeRange(dist, 0.0, 20.0, 0.0, 1.0));
                    }
                `
            });
        }
        
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(modelChildren);
            const target = intersects[0];
            
            if (target && target.object.isMesh) {
                const targetMesh = target.object;
                selectedMeshName = meshUuidToName[targetMesh.uuid] || targetMesh.uuid;
            } else {
                selectedMeshName = null;
            }
        }
        
        document.getElementById('debug').innerHTML = 'Loading new shoe...';
        
        var loader = new THREE.GLTFLoader();
        loader.load('shoe-nodraco.glb', 
            function(gltf) {
                document.getElementById('debug').innerHTML = 'NEW SHOE LOADED!';
                model = gltf.scene;
                
                // Setup materials with distance shader
                model.traverse(function(child) {
                    if (child.isMesh) {
                        modelChildren.push(child);
                        meshUuidToName[child.uuid] = child.name || child.uuid;
                        
                        // Store original color
                        var originalColor = new THREE.Color(0x00ff00);
                        child.material = createDistanceMaterial(originalColor);
                    }
                });
                
                var box = new THREE.Box3().setFromObject(model);
                var size = box.getSize(new THREE.Vector3());
                var maxSize = Math.max(size.x, size.y, size.z);
                var scale = 50 / maxSize;
                model.position.set(0, 0, 0);
                model.scale.setScalar(scale);
                scene.add(model);
                
                // Add mouse event listener
                window.addEventListener('mousemove', onMouseMove);
                
                document.getElementById('debug').innerHTML = 'Hover over shoe parts to highlight edges!';
            },
            function(progress) {
                console.log('Loading:', (progress.loaded/progress.total*100) + '%');
            },
            function(error) {
                document.getElementById('debug').innerHTML = 'FAILED: ' + error.message;
                console.error('Error:', error);
            }
        );
        
        window.addEventListener('scroll', function() { scrollY = window.pageYOffset; });
        
        function render() {
            if (!model) return;
            
            // Apply scroll rotation
            var rot = scrollY * 0.005;
            model.rotation.y = rot;
            model.rotation.x = rot * 0.3;
            
            // Render renderTargetA (all meshes except hovered)
            modelChildren.forEach(function(mesh) {
                if (selectedMeshName && meshUuidToName[mesh.uuid] === selectedMeshName) {
                    mesh.visible = false;
                } else {
                    mesh.visible = true;
                }
            });
            
            renderer.setRenderTarget(renderTargetA);
            renderer.render(scene, camera);
            
            // Render renderTargetB (only hovered mesh)
            modelChildren.forEach(function(mesh) {
                if (selectedMeshName && meshUuidToName[mesh.uuid] === selectedMeshName) {
                    mesh.visible = true;
                } else {
                    mesh.visible = false;
                }
            });
            
            renderer.setRenderTarget(renderTargetB);
            renderer.render(scene, camera);
            
            // Reset visibility
            modelChildren.forEach(function(mesh) {
                mesh.visible = true;
            });
            
            // Apply Sobel effect with dual render targets
            effectSobel.uniforms.tDiffuse1.value = renderTargetA.texture;
            effectSobel.uniforms.tDiffuse2.value = renderTargetB.texture;
            
            // Final render to screen
            renderer.setRenderTarget(null);
            
            // Create a full-screen quad to display the Sobel effect
            var geometry = new THREE.PlaneGeometry(2, 2);
            var quad = new THREE.Mesh(geometry, effectSobel);
            var quadScene = new THREE.Scene();
            quadScene.add(quad);
            var quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            
            renderer.render(quadScene, quadCamera);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            render();
        }
        animate();
    </script>
</body>
</html>