<!DOCTYPE html>
<html>
<head><title>Shoe Test</title></head>
<body style="margin:0;background:black;font-family:Arial;">
    <div id="container" style="position:fixed;width:100vw;height:100vh;"></div>
    <div style="position:absolute;top:20px;left:20px;color:white;z-index:100;">
        <h2>SOLK Shoe Wireframe</h2>
        <p>Scroll to rotate â€¢ Drag to orbit</p>
    </div>
    <div id="debug" style="position:absolute;top:100px;left:20px;color:red;z-index:100;font-size:20px;">LOADING...</div>
    
    <!-- Camera Controls UI -->
    <div style="position:absolute;top:20px;right:20px;color:white;z-index:100;background:rgba(0,0,0,0.7);padding:15px;border-radius:8px;">
        <h3 style="margin:0 0 10px 0;">Camera Controls</h3>
        <div style="margin:5px 0;">
            <label>Auto Rotate: </label>
            <input type="checkbox" id="autoRotate" onchange="toggleAutoRotate()">
        </div>
        <div style="margin:5px 0;">
            <label>Rotation Speed: </label>
            <input type="range" id="rotSpeed" min="0.001" max="0.02" step="0.001" value="0.005" oninput="updateRotSpeed()">
        </div>
        <div style="margin:5px 0;">
            <button onclick="resetCamera()" style="padding:5px 10px;background:#333;color:white;border:none;border-radius:4px;">Reset View</button>
        </div>
        <div style="margin:5px 0;">
            <button onclick="resetModel()" style="padding:5px 10px;background:#333;color:white;border:none;border-radius:4px;">Center Model</button>
        </div>
        <hr style="margin:10px 0;">
        <h4 style="margin:5px 0;">Shader Controls</h4>
        <div style="margin:5px 0;">
            <label>Edge Threshold: </label>
            <input type="range" id="edgeThreshold" min="0.0001" max="0.01" step="0.0001" value="0.001" oninput="updateShader()">
            <span id="thresholdValue">0.001</span>
        </div>
        <div style="margin:5px 0;">
            <label>Line Width: </label>
            <input type="range" id="lineWidth" min="0.5" max="3.0" step="0.1" value="1.0" oninput="updateShader()">
            <span id="lineWidthValue">1.0</span>
        </div>
        <div style="margin:5px 0;">
            <label>Edge Intensity: </label>
            <input type="range" id="edgeIntensity" min="0.1" max="2.0" step="0.1" value="1.0" oninput="updateShader()">
            <span id="intensityValue">1.0</span>
        </div>
    </div>
    
    <div style="height:300vh;"></div>

    <script src="three.min.js"></script>
    <script src="GLTFLoader.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="EffectComposer.js"></script>
    <script src="RenderPass.js"></script>
    <script src="ShaderPass.js"></script>
    <script src="SobelOperatorShader.js"></script>
    <script>
        var scene, camera, renderer, model, controls, scrollY = 0;
        var rotationSpeed = 0.005;
        var autoRotate = false;
        var modelGroup; // Group to hold the model for proper rotation
        var composer; // Post-processing composer
        var sobelPass; // Store reference to sobel pass for real-time updates
        
        // Custom Sobel fragment shader from the Codrops article
        const customSobelFragmentShader = `
            uniform vec2 resolution;
            uniform sampler2D tDiffuse;
            uniform float edgeThreshold;
            uniform float lineWidth;
            uniform float edgeIntensity;
            varying vec2 vUv;

            float sobel(sampler2D tDiffuse, vec2 texel) {
                // kernel definition (in glsl matrices are filled in column-major order)
                const mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 ); // x direction kernel
                const mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 ); // y direction kernel

                // fetch the 3x3 neighbourhood of a fragment
                // first column
                float tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;
                float tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;
                float tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;

                // second column
                float tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;
                float tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;
                float tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;

                // third column
                float tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;
                float tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;
                float tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;

                // gradient value in x direction
                float valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 +
                    Gx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 +
                    Gx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2;

                // gradient value in y direction
                float valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 +
                    Gy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 +
                    Gy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2;

                // magnitude of the total gradient
                float G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );
                return G;
            }

            void main() {
                vec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y ) * lineWidth;
                vec4 t = texture2D(tDiffuse, vUv);    
                float G = sobel(tDiffuse, texel);
                
                // Use adjustable threshold and intensity
                G = G > edgeThreshold ? edgeIntensity : 0.0;
                G = clamp(G, 0.0, 1.0);
                    
                gl_FragColor = vec4(vec3(G), 1.0);
            }
        `;

        document.getElementById('debug').innerHTML = 'Starting...';
            
            // Basic Three.js setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 8); // Move camera back to see the larger shoe
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableZoom = false; // Disable zoom to prevent conflict with scroll
        
        // Setup post-processing
        composer = new THREE.EffectComposer(renderer);
        
        // Basic render pass
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);
        
        // Custom Sobel edge detection pass
        const sobelShader = THREE.SobelOperatorShader;
        sobelShader.fragmentShader = customSobelFragmentShader;
        
        sobelPass = new THREE.ShaderPass(sobelShader);
        sobelPass.uniforms['resolution'].value.x = window.innerWidth * Math.min(window.devicePixelRatio, 2);
        sobelPass.uniforms['resolution'].value.y = window.innerHeight * Math.min(window.devicePixelRatio, 2);
        
        // Add custom uniforms for shader controls
        sobelPass.uniforms['edgeThreshold'] = { value: 0.001 };
        sobelPass.uniforms['lineWidth'] = { value: 1.0 };
        sobelPass.uniforms['edgeIntensity'] = { value: 1.0 };
        
        sobelPass.renderToScreen = true;
        composer.addPass(sobelPass);
        
        var light = new THREE.AmbientLight(0xffffff, 1);
        scene.add(light);
        
        document.getElementById('debug').innerHTML = 'Loading shoe.glb...';
        
        // Create model group for proper rotation
        modelGroup = new THREE.Group();
        scene.add(modelGroup);
        
        // Create fallback cube immediately
        var cube = new THREE.Mesh(
            new THREE.BoxGeometry(3, 3, 3), 
            new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true })
        );
        modelGroup.add(cube);
        model = cube;
        document.getElementById('debug').innerHTML = 'WHITE CUBE VISIBLE (fallback)';
        
        // Try to load GLB
        var loader = new THREE.GLTFLoader();
        loader.load('shoe.glb', 
            function(gltf) {
                document.getElementById('debug').innerHTML = 'GLB SUCCESS! Replacing cube...';
                modelGroup.remove(cube); // Remove fallback from group
                model = gltf.scene;
                
                // Apply different colored materials for edge detection
                var materialColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
                var colorIndex = 0;
                
                model.traverse(function(child) {
                    if (child.isMesh) {
                        // Assign unique colors to different parts for better edge detection
                        child.material = new THREE.MeshBasicMaterial({ 
                            color: materialColors[colorIndex % materialColors.length]
                        });
                        colorIndex++;
                    }
                });
                
                // First scale the model to a good size
                var box = new THREE.Box3().setFromObject(model);
                var size = box.getSize(new THREE.Vector3());
                var maxSize = Math.max(size.x, size.y, size.z);
                var scale = maxSize > 0 ? 9.6 / maxSize : 1; // 80% of previous size (12 * 0.8 = 9.6)
                model.scale.setScalar(scale);
                
                // After scaling, recalculate the bounding box and center
                box = new THREE.Box3().setFromObject(model);
                var center = box.getCenter(new THREE.Vector3());
                var scaledSize = box.getSize(new THREE.Vector3());
                
                // Position model so its center is at origin, then adjust for product exploration
                model.position.set(-center.x, -center.y + 3, -center.z);
                
                // Move the entire modelGroup to adjust pivot point inside the shoe
                // This way scaling works properly but rotation pivot is moved
                var pivotOffset = scaledSize.x * 0.2; // Move pivot 20% towards toe
                modelGroup.position.set(-pivotOffset, 0, 0);
                
                // Rotate the base position -45 degrees on Z-axis
                model.rotation.z = -Math.PI / 4; // -45 degrees in radians
                
                modelGroup.add(model);
                document.getElementById('debug').innerHTML = 'SHOE LOADED! Scroll to rotate.';
            },
            undefined,
            function(error) {
                document.getElementById('debug').innerHTML = 'GLB FAILED - keeping cube';
            }
        );
        
        // Animation
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate the model group ONLY around Y-axis (vertical)
            if (modelGroup) {
                if (autoRotate) {
                    modelGroup.rotation.y += rotationSpeed;
                } else {
                    var rot = scrollY * rotationSpeed;
                    modelGroup.rotation.y = rot;
                    // No X rotation - only Y-axis rotation
                }
            }
            
            controls.update();
            composer.render(); // Use composer instead of direct renderer
        }
        animate();
        
        // UI Control Functions
        function toggleAutoRotate() {
            autoRotate = document.getElementById('autoRotate').checked;
        }
        
        function updateRotSpeed() {
            rotationSpeed = parseFloat(document.getElementById('rotSpeed').value);
        }
        
        function resetCamera() {
            camera.position.set(0, 0, 8);
            controls.target.set(0, 0, 0);
            controls.update();
        }
        
        function resetModel() {
            if (modelGroup) {
                modelGroup.rotation.set(0, 0, 0);
                scrollY = 0;
            }
        }
        
        function updateShader() {
            if (sobelPass) {
                const threshold = parseFloat(document.getElementById('edgeThreshold').value);
                const lineWidth = parseFloat(document.getElementById('lineWidth').value);
                const intensity = parseFloat(document.getElementById('edgeIntensity').value);
                
                sobelPass.uniforms['edgeThreshold'].value = threshold;
                sobelPass.uniforms['lineWidth'].value = lineWidth;
                sobelPass.uniforms['edgeIntensity'].value = intensity;
                
                // Update display values
                document.getElementById('thresholdValue').textContent = threshold.toFixed(4);
                document.getElementById('lineWidthValue').textContent = lineWidth.toFixed(1);
                document.getElementById('intensityValue').textContent = intensity.toFixed(1);
            }
        }
        
        window.addEventListener('scroll', function(e) { 
            e.preventDefault();
            scrollY = window.pageYOffset; 
        });
        
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            
            // Update Sobel shader resolution
            composer.passes[1].uniforms['resolution'].value.x = window.innerWidth * Math.min(window.devicePixelRatio, 2);
            composer.passes[1].uniforms['resolution'].value.y = window.innerHeight * Math.min(window.devicePixelRatio, 2);
        });
        
    </script>
</body>
</html>